# Vulnerability Patterns Reference

## Table of Contents
1. [Reentrancy](#reentrancy)
2. [Access Control](#access-control)
3. [Integer Issues](#integer-issues)
4. [Flash Loan Attacks](#flash-loan-attacks)
5. [Oracle Manipulation](#oracle-manipulation)
6. [Front-Running](#front-running)

## Reentrancy

### Classic Reentrancy

**Pattern**: External call before state update allows recursive calls.

```solidity
// VULNERABLE
function withdraw() external {
    uint256 balance = balances[msg.sender];
    (bool success, ) = msg.sender.call{value: balance}("");
    require(success);
    balances[msg.sender] = 0;  // Too late!
}
```

**Attack**:
```solidity
contract Attacker {
    Vulnerable target;
    
    function attack() external payable {
        target.deposit{value: 1 ether}();
        target.withdraw();
    }
    
    receive() external payable {
        if (address(target).balance >= 1 ether) {
            target.withdraw();  // Re-enter before balance updated
        }
    }
}
```

**Fix**:
```solidity
function withdraw() external nonReentrant {
    uint256 balance = balances[msg.sender];
    balances[msg.sender] = 0;  // Update first
    (bool success, ) = msg.sender.call{value: balance}("");
    require(success);
}
```

### Cross-Function Reentrancy

**Pattern**: Reentrancy across multiple functions sharing state.

```solidity
// VULNERABLE
function transfer(address to, uint256 amount) external {
    require(balances[msg.sender] >= amount);
    balances[to] += amount;
    balances[msg.sender] -= amount;
}

function withdrawAll() external {
    uint256 balance = balances[msg.sender];
    (bool success, ) = msg.sender.call{value: balance}("");
    require(success);
    balances[msg.sender] = 0;
}
// Attacker can call transfer() during withdrawAll() callback
```

### Read-Only Reentrancy

**Pattern**: View functions return stale state during reentrancy.

```solidity
// VULNERABLE - Oracle reads stale LP token price during reentrancy
function getPrice() external view returns (uint256) {
    return totalAssets / totalSupply;  // Can be manipulated mid-transaction
}
```

## Access Control

### Missing Modifier

```solidity
// VULNERABLE
function setOwner(address newOwner) external {
    owner = newOwner;  // Anyone can call!
}

// SECURE
function setOwner(address newOwner) external onlyOwner {
    require(newOwner != address(0), "Zero address");
    owner = newOwner;
}
```

### Incorrect Modifier Logic

```solidity
// VULNERABLE - Logic error
modifier onlyOwner() {
    if (msg.sender == owner) {
        _;  // Only executes if owner, but doesn't revert otherwise!
    }
}

// SECURE
modifier onlyOwner() {
    require(msg.sender == owner, "Not owner");
    _;
}
```

### tx.origin Vulnerability

```solidity
// VULNERABLE
function transferOwnership(address newOwner) external {
    require(tx.origin == owner);  // Can be phished!
    owner = newOwner;
}

// SECURE
function transferOwnership(address newOwner) external {
    require(msg.sender == owner);
    owner = newOwner;
}
```

## Integer Issues

### Overflow/Underflow (Pre-0.8.0)

```solidity
// VULNERABLE (Solidity < 0.8.0)
function transfer(address to, uint256 amount) external {
    balances[msg.sender] -= amount;  // Can underflow!
    balances[to] += amount;          // Can overflow!
}

// SECURE (using SafeMath)
function transfer(address to, uint256 amount) external {
    balances[msg.sender] = balances[msg.sender].sub(amount);
    balances[to] = balances[to].add(amount);
}
```

### Division Precision Loss

```solidity
// VULNERABLE
function calculateShare(uint256 amount, uint256 totalShares) external view returns (uint256) {
    return amount / totalShares * price;  // Precision loss!
}

// SECURE
function calculateShare(uint256 amount, uint256 totalShares) external view returns (uint256) {
    return amount * price / totalShares;  // Multiply first
}
```

## Flash Loan Attacks

### Price Manipulation

```solidity
// VULNERABLE - Uses spot price
function getPrice() public view returns (uint256) {
    (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();
    return reserve1 * 1e18 / reserve0;  // Manipulable with flash loan
}

// SECURE - Use TWAP or Chainlink
function getPrice() public view returns (uint256) {
    (, int256 price, , , ) = priceFeed.latestRoundData();
    return uint256(price);
}
```

### Governance Attack

```solidity
// VULNERABLE - Snapshot at proposal time
function propose(address[] memory targets, bytes[] memory calldatas) external {
    require(getVotes(msg.sender) >= proposalThreshold);  // Flash loan votes!
    // ...
}

// SECURE - Snapshot from previous block
function propose(...) external {
    require(getPastVotes(msg.sender, block.number - 1) >= proposalThreshold);
    // ...
}
```

## Oracle Manipulation

### Spot Price Oracle

```solidity
// VULNERABLE
function liquidate(address user) external {
    uint256 price = dex.getSpotPrice(token);  // Manipulable!
    require(getCollateralValue(user, price) < getDebtValue(user));
    // ...
}

// SECURE
function liquidate(address user) external {
    uint256 price = chainlinkOracle.getPrice(token);  // Decentralized oracle
    require(getCollateralValue(user, price) < getDebtValue(user));
    // ...
}
```

### Stale Price Data

```solidity
// VULNERABLE - No freshness check
function getPrice() external view returns (uint256) {
    (, int256 price, , , ) = priceFeed.latestRoundData();
    return uint256(price);
}

// SECURE
function getPrice() external view returns (uint256) {
    (, int256 price, , uint256 updatedAt, ) = priceFeed.latestRoundData();
    require(block.timestamp - updatedAt < 1 hours, "Stale price");
    require(price > 0, "Invalid price");
    return uint256(price);
}
```

## Front-Running

### Sandwich Attack

```solidity
// VULNERABLE - No slippage protection
function swap(address tokenIn, address tokenOut, uint256 amountIn) external {
    uint256 amountOut = router.swapExactTokensForTokens(
        amountIn,
        0,  // No minimum output!
        path,
        msg.sender,
        deadline
    );
}

// SECURE
function swap(..., uint256 minAmountOut) external {
    uint256 amountOut = router.swapExactTokensForTokens(
        amountIn,
        minAmountOut,  // User-specified minimum
        path,
        msg.sender,
        deadline
    );
}
```

### Commit-Reveal Pattern

```solidity
// SECURE - Two-phase commit
mapping(bytes32 => uint256) public commitments;

function commit(bytes32 hash) external {
    commitments[hash] = block.number;
}

function reveal(uint256 secret, uint256 value) external {
    bytes32 hash = keccak256(abi.encodePacked(msg.sender, secret, value));
    require(commitments[hash] != 0, "No commitment");
    require(block.number > commitments[hash] + 10, "Too early");
    // Process reveal...
}
```
