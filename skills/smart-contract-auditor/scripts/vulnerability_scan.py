#!/usr/bin/env python3
"""
Scan Solidity smart contracts for common vulnerability patterns.
Performs static analysis without requiring compilation.
"""

import argparse
import json
import re
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List, Dict, Tuple


@dataclass
class Finding:
    """Represents a security finding."""
    severity: str
    title: str
    description: str
    location: str
    line_number: int
    recommendation: str


# Vulnerability patterns to scan for
VULNERABILITY_PATTERNS = {
    "critical": [
        {
            "name": "Reentrancy",
            "pattern": r"\.call\{value:.*\}.*\n(?:(?!.*=\s*0)(?!.*=\s*false)(?!.*delete\s).*\n)*.*(?:balances|balance|amount)\[",
            "description": "Potential reentrancy: external call before state update",
            "recommendation": "Update state before external calls or use ReentrancyGuard"
        },
        {
            "name": "Unprotected Self-Destruct",
            "pattern": r"function\s+\w+\s*\([^)]*\)\s*(?:external|public)(?:(?!onlyOwner|require\s*\(\s*msg\.sender).)*(selfdestruct|suicide)",
            "description": "Self-destruct without access control",
            "recommendation": "Add onlyOwner modifier or remove selfdestruct"
        },
        {
            "name": "Delegatecall to User Input",
            "pattern": r"\.delegatecall\s*\([^)]*(?:msg\.data|_data|data|calldata)",
            "description": "Delegatecall with user-controlled input",
            "recommendation": "Avoid delegatecall with untrusted input"
        }
    ],
    "high": [
        {
            "name": "Missing Access Control",
            "pattern": r"function\s+(?:set|update|change|modify|withdraw|transfer|mint)\w*\s*\([^)]*\)\s*(?:external|public)\s*(?!.*(?:onlyOwner|onlyAdmin|require\s*\(\s*msg\.sender|_checkRole))",
            "description": "Sensitive function without access control",
            "recommendation": "Add appropriate access control modifier"
        },
        {
            "name": "Unchecked External Call",
            "pattern": r"\.call\{[^}]*\}\s*\([^)]*\)\s*;(?!\s*(?:require|if|assert))",
            "description": "External call return value not checked",
            "recommendation": "Check return value: (bool success, ) = addr.call{...}(...); require(success);"
        },
        {
            "name": "tx.origin Authentication",
            "pattern": r"require\s*\(\s*tx\.origin\s*==|tx\.origin\s*==\s*msg\.sender",
            "description": "Using tx.origin for authentication",
            "recommendation": "Use msg.sender instead of tx.origin"
        },
        {
            "name": "Arbitrary External Call",
            "pattern": r"\.call\s*\([^)]*\)|\.delegatecall\s*\([^)]*\)|\.staticcall\s*\([^)]*\)",
            "description": "Low-level call detected - verify safety",
            "recommendation": "Ensure call target and data are validated"
        }
    ],
    "medium": [
        {
            "name": "Block Timestamp Dependence",
            "pattern": r"block\.timestamp\s*[<>=]|now\s*[<>=]",
            "description": "Timestamp used in comparison (can be manipulated by miners)",
            "recommendation": "Avoid precise timestamp comparisons for critical logic"
        },
        {
            "name": "Floating Pragma",
            "pattern": r"pragma\s+solidity\s*\^",
            "description": "Floating pragma version",
            "recommendation": "Lock pragma to specific version: pragma solidity 0.8.19;"
        },
        {
            "name": "Missing Zero Address Check",
            "pattern": r"function\s+(?:set|update|change)\w*\s*\([^)]*address\s+\w+[^)]*\)(?:(?!require\s*\([^)]*!=\s*address\s*\(\s*0\s*\))(?!require\s*\([^)]*!=\s*0x0).)*(owner|admin|recipient|to)\s*=",
            "description": "Address parameter not validated for zero address",
            "recommendation": "Add: require(addr != address(0), 'Zero address');"
        },
        {
            "name": "Centralization Risk",
            "pattern": r"onlyOwner|Ownable|owner\s*\(\s*\)",
            "description": "Centralized control detected",
            "recommendation": "Consider multi-sig or timelock for owner functions"
        }
    ],
    "low": [
        {
            "name": "Missing Event Emission",
            "pattern": r"function\s+(?:set|update|change|transfer)\w*[^}]+\}(?!.*emit\s+\w+)",
            "description": "State-changing function without event emission",
            "recommendation": "Emit events for important state changes"
        },
        {
            "name": "Magic Numbers",
            "pattern": r"(?:require|if)\s*\([^)]*(?<![a-zA-Z_])(?:100|1000|10000|1e18|1 ether|1 days)(?![a-zA-Z_])",
            "description": "Magic number in condition",
            "recommendation": "Use named constants for clarity"
        },
        {
            "name": "TODO/FIXME Comments",
            "pattern": r"//\s*(?:TODO|FIXME|XXX|HACK|BUG)",
            "description": "Unresolved TODO/FIXME comment",
            "recommendation": "Resolve or document the issue"
        }
    ],
    "informational": [
        {
            "name": "Public Function Could Be External",
            "pattern": r"function\s+\w+\s*\([^)]*\)\s*public\s+(?!view|pure|virtual|override)",
            "description": "Public function not called internally could be external",
            "recommendation": "Use external for gas optimization if not called internally"
        },
        {
            "name": "Unused Variable",
            "pattern": r"(?:uint|int|address|bool|string|bytes)\d*\s+(?:private|internal|public)?\s*(\w+)\s*;",
            "description": "Potential unused state variable",
            "recommendation": "Remove unused variables to save gas"
        }
    ]
}


def scan_file(file_path: Path) -> List[Finding]:
    """Scan a single Solidity file for vulnerabilities."""
    findings = []
    
    try:
        content = file_path.read_text()
    except Exception as e:
        print(f"Error reading {file_path}: {e}", file=sys.stderr)
        return findings
    
    lines = content.split('\n')
    
    for severity, patterns in VULNERABILITY_PATTERNS.items():
        for pattern_info in patterns:
            matches = list(re.finditer(pattern_info["pattern"], content, re.MULTILINE | re.IGNORECASE))
            
            for match in matches:
                # Calculate line number
                line_num = content[:match.start()].count('\n') + 1
                
                # Get context (the matched line)
                context_start = max(0, line_num - 1)
                context_end = min(len(lines), line_num + 2)
                location = f"{file_path.name}:L{line_num}"
                
                finding = Finding(
                    severity=severity,
                    title=pattern_info["name"],
                    description=pattern_info["description"],
                    location=location,
                    line_number=line_num,
                    recommendation=pattern_info["recommendation"]
                )
                findings.append(finding)
    
    return findings


def scan_directory(dir_path: Path) -> Dict[str, List[Finding]]:
    """Scan all Solidity files in a directory."""
    results = {}
    
    sol_files = list(dir_path.rglob("*.sol"))
    
    for sol_file in sol_files:
        findings = scan_file(sol_file)
        if findings:
            results[str(sol_file)] = findings
    
    return results


def generate_summary(all_findings: Dict[str, List[Finding]]) -> Dict:
    """Generate a summary of all findings."""
    summary = {
        "total_files": len(all_findings),
        "total_findings": 0,
        "by_severity": {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "informational": 0
        }
    }
    
    for findings in all_findings.values():
        for finding in findings:
            summary["total_findings"] += 1
            summary["by_severity"][finding.severity] += 1
    
    return summary


def main():
    parser = argparse.ArgumentParser(description="Scan Solidity contracts for vulnerabilities")
    parser.add_argument("--contract", required=True, help="Path to contract file or directory")
    parser.add_argument("--output", help="Output JSON file path")
    parser.add_argument("--severity", choices=["critical", "high", "medium", "low", "informational"],
                        help="Minimum severity to report")
    
    args = parser.parse_args()
    
    path = Path(args.contract)
    
    if not path.exists():
        print(f"Error: Path does not exist: {path}", file=sys.stderr)
        sys.exit(1)
    
    print(f"Scanning: {path}")
    print("-" * 50)
    
    # Scan files
    if path.is_file():
        findings = scan_file(path)
        all_findings = {str(path): findings} if findings else {}
    else:
        all_findings = scan_directory(path)
    
    # Filter by severity if specified
    severity_order = ["critical", "high", "medium", "low", "informational"]
    if args.severity:
        min_index = severity_order.index(args.severity)
        allowed_severities = set(severity_order[:min_index + 1])
        
        for file_path in all_findings:
            all_findings[file_path] = [
                f for f in all_findings[file_path]
                if f.severity in allowed_severities
            ]
    
    # Generate summary
    summary = generate_summary(all_findings)
    
    # Print results
    print(f"\nScan Summary:")
    print(f"  Files scanned: {summary['total_files']}")
    print(f"  Total findings: {summary['total_findings']}")
    print(f"\nBy Severity:")
    for sev, count in summary["by_severity"].items():
        if count > 0:
            print(f"  {sev.capitalize()}: {count}")
    
    # Print detailed findings
    if all_findings:
        print("\n" + "=" * 50)
        print("DETAILED FINDINGS")
        print("=" * 50)
        
        for file_path, findings in all_findings.items():
            if findings:
                print(f"\n{file_path}:")
                for finding in findings:
                    print(f"\n  [{finding.severity.upper()}] {finding.title}")
                    print(f"  Location: {finding.location}")
                    print(f"  Description: {finding.description}")
                    print(f"  Recommendation: {finding.recommendation}")
    
    # Output to JSON
    if args.output:
        output_data = {
            "summary": summary,
            "findings": {
                fp: [
                    {
                        "severity": f.severity,
                        "title": f.title,
                        "description": f.description,
                        "location": f.location,
                        "line_number": f.line_number,
                        "recommendation": f.recommendation
                    }
                    for f in findings
                ]
                for fp, findings in all_findings.items()
            }
        }
        
        with open(args.output, "w") as f:
            json.dump(output_data, f, indent=2)
        print(f"\nResults saved to: {args.output}")


if __name__ == "__main__":
    main()
